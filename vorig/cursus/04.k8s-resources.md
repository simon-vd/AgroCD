---
sidebarDepth: 1
---

# ðŸ“– Kubernetes Resources

As mentioned before, Kubernetes is a collection of resources. These resources are defined in a `spec` written in YAML files. The YAML files are then sent to the cluster. From that point on, those resources are then managed by the cluster. In many cases those resources will create new resources as needed. But no worries we'll learn more about that later.

What does a simple app look like in Kubernetes? This diagram tries to describe it:

![typical deployment](./typical-deployment.png)

You will see a lot of terms being used so let's go over them:

## Pod

We'll be starting from the very **lowest** level: the pod.

> **Pod**: a group of whales

This is often called the atom of Kubernetes. It is the smallest visible level of an application. But it is where everything runs.

A pod has one or more containers, usually ONE. In case there are several we call these "sidecar containers", why would you use them? To add functionality to your main container. For example, you could have a sidecar container that does logging or monitoring.

All containers in a pod share one IP and one network. They have no isolation between them.
Because of security concerns this could introduce, the rule is to host one pod per application (so don't even think about putting a webserver and a database in one pod)!

A pod will look something like this:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
      ports:
        - containerPort: 80
      volumeMounts:
        - name: my-volume
          mountPath: /data
  volumes:
    - name: my-volume
      persistentVolumeClaim:
        claimName: my-pvc
```

Popular parts of the pod are:

- `containers`: the containers that run in the pod
- `volumes`: the volumes that are mounted in the pod, either from secrets, configmaps or persistent volumes
- `initContainers`: containers that run before the main containers, used for example to deploy a database schema update
- `restartPolicy`: the policy for restarting the pod, can be `Always`, `OnFailure` or `Never`
- `nodeSelector`: the node selector for the pod, used to schedule the pod on a specific node or group of nodes

A list of all available fields can be printed with `kubectl explain pod.spec` or we can refer you to [the api documentation](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#pod-v1-core).

Let's look at the pods running in our cluster:

```bash
$ kubectl get pods -n kube-system
NAME                                         READY   STATUS    RESTARTS   AGE
coredns-565d847f94-8wmbk                     1/1     Running   0          3h16m
coredns-565d847f94-dxz2j                     1/1     Running   0          3h16m
etcd-kind-control-plane                      1/1     Running   0          3h16m
kindnet-zlr76                                1/1     Running   0          3h16m
kube-apiserver-kind-control-plane            1/1     Running   0          3h16m
kube-controller-manager-kind-control-plane   1/1     Running   0          3h16m
kube-proxy-wrvkh                             1/1     Running   0          3h16m
kube-scheduler-kind-control-plane            1/1     Running   0          3h16m
```

**But, you wouldnâ€™t want to work on this atomic level right? That's why we will never create pods ourselves!**

## Deployment

Deployments are what drive applications! When we want to host a container in Kubernetes we will most of the times be using a deployment.

What can Deployment do for us?

- They take care of updating
  - They will create a new set of pods (ReplicaSet), wait till they are started then delete the old ones
  - Should this fail it will automaticaly stop
  - This causes a rolling update **without downtime**
- They take care of scaling
  - We can ask to scale up or down the pods over multiple servers
- They recreate pods should a server crash (or we delete them so they restart)

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-world-deployment
  namespace: default
spec:
  selector:
    matchLabels:
      app: hello-world
  replicas: 1
  template:
    metadata:
      labels:
        app: hello-world
    spec: # this is our pod spec!
      containers:
        - name: nginx
          image: nginxdemos/hello
          ports:
            - containerPort: 80
              name: http # from now on we can use the name http to refer to this port
```

Want to know what all these words mean? [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)

Let's try it out, save this config as `deployment.yaml` and run:

```bash
kubectl apply -f deployment.yaml
```

Let's check if it worked:

```bash
kubectl get deploy # deploy is short for deployment(s)
```

If all was okay you will see something like this:

```bash
NAME                     READY   UP-TO-DATE   AVAILABLE   AGE
hello-world-deployment   1/1     1            1           43s
```

Let's run a `kubectl describe deploy hello-world-deployment` to see more details:

```
Name:                   hello-world-deployment
Namespace:              default
CreationTimestamp:      Mon, 03 Oct 2022 13:51:21 +0200
Labels:                 <none>
Selector:               app=hello-world
Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=hello-world
  Containers:
   nginx:
    Image:        nginxdemos/hello
    Port:         80/TCP
    Host Port:    0/TCP
    Liveness:     http-get http://:http/ delay=5s timeout=1s period=5s #success=1 #failure=3
    Readiness:    http-get http://:http/ delay=2s timeout=1s period=10s #success=1 #failure=3
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   hello-world-deployment-5dc7657797 (1/1 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  96s   deployment-controller  Scaled up replica set hello-world-deployment-5dc7657797 to 1
```

You can see it made a `ReplicaSet` which it named `hello-world-deployment-5dc7657797`.
Let's look into that using `kubectl describe rs hello-world-deployment-5dc7657797` (again `rs` is short for `replicaset`, both work! Oh also the name on your machine will be different)

```
Name:           hello-world-deployment-5dc7657797
Namespace:      default
Selector:       app=hello-world,pod-template-hash=5dc7657797
Labels:         app=hello-world
                pod-template-hash=5dc7657797
Annotations:    deployment.kubernetes.io/desired-replicas: 1
                deployment.kubernetes.io/max-replicas: 2
                deployment.kubernetes.io/revision: 1
Controlled By:  Deployment/hello-world-deployment
Replicas:       1 current / 1 desired
Pods Status:    1 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  app=hello-world
           pod-template-hash=5dc7657797
  Containers:
   nginx:
    Image:        nginxdemos/hello
    Port:         80/TCP
    Host Port:    0/TCP
    Liveness:     http-get http://:http/ delay=5s timeout=1s period=5s #success=1 #failure=3
    Readiness:    http-get http://:http/ delay=2s timeout=1s period=10s #success=1 #failure=3
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Events:
  Type    Reason            Age    From                   Message
  ----    ------            ----   ----                   -------
  Normal  SuccessfulCreate  3m49s  replicaset-controller  Created pod: hello-world-deployment-5dc7657797-wkdnd
```

We see this creates a `pod`! Let's have a look using `kubectl describe pod hello-world-deployment-5dc7657797-wkdnd`

```
Name:         hello-world-deployment-5dc7657797-wkdnd
Namespace:    default
Priority:     0
Node:         kind-control-plane/172.20.0.2
Start Time:   Mon, 03 Oct 2022 13:51:21 +0200
Labels:       app=hello-world
              pod-template-hash=5dc7657797
Annotations:  <none>
Status:       Running
IP:           10.244.0.5
IPs:
  IP:           10.244.0.5
Controlled By:  ReplicaSet/hello-world-deployment-5dc7657797
Containers:
  nginx:
    Container ID:   containerd://d4c35c5f1278d967aab8358b4dee215eff4ca6be4e3952cfbd1a785a2d698c35
    Image:          nginxdemos/hello
    Image ID:       docker.io/nginxdemos/hello@sha256:224be382373facb075e5ed867f057e14f35132f91b7b59de132fbdee03dd140d
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Mon, 03 Oct 2022 13:51:31 +0200
    Ready:          True
    Restart Count:  0
    Liveness:       http-get http://:http/ delay=5s timeout=1s period=5s #success=1 #failure=3
    Readiness:      http-get http://:http/ delay=2s timeout=1s period=10s #success=1 #failure=3
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-4hkq6 (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  kube-api-access-4hkq6:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       <nil>
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute for 300s
                             node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age    From                         Message
  ----    ------     ----   ----                         -------
  Normal  Scheduled  4m31s  default-scheduler            Successfully assigned default/hello-world-deployment-5dc7657797-wkdnd to kind-control-plane
  Normal  Pulling    4m30s  kubelet, kind-control-plane  Pulling image "nginxdemos/hello"
  Normal  Pulled     4m21s  kubelet, kind-control-plane  Successfully pulled image "nginxdemos/hello" in 9.403020325s
  Normal  Created    4m21s  kubelet, kind-control-plane  Created container nginx
  Normal  Started    4m21s  kubelet, kind-control-plane  Started container nginx
```

:::tip
You can do this from Pod -> ReplicaSet -> Deployment by following the `Controlled By` field! This is what Kubernetes uses to track down it's chain of command
:::

A Deployment is a type of Kubernetes resource that creates underlying resources! This is a very common pattern in Kubernetes.

A deployment will create one `ReplicaSet` per update (to do rolling upgrade). A `ReplicaSet` is then responsible to create the `Pods` that are needed and scale them (thus the name). We rarely create `ReplicaSets` directly, we use `Deployments` instead.

![deployment](./deployment.png)

Let's scale up a bit!

```
kubectl scale deployment hello-world-deployment --replicas=3
```

This is a shortcut to change the `replicas:` field in the `Deployment` resource. We can also do this by editing the resource directly.

```bash
$ kubectl get pods
NAME                                      READY   STATUS              RESTARTS   AGE
hello-world-deployment-5dc7657797-vddkc   0/1     ContainerCreating   0          2s
hello-world-deployment-5dc7657797-wkdnd   1/1     Running             0          37m
hello-world-deployment-5dc7657797-zbwd9   0/1     ContainerCreating   0          2s
```

Good now we got 3! If you have set up a multi-node cluster, k8s will divide the pods among all the worker nodes. To see which pod is running on which node:

```bash
$ kubectl get pods -o wide
NAME                                      READY   STATUS    RESTARTS   AGE   IP           NODE           NOMINATED NODE   READINESS GATES
hello-world-deployment-5dc7657797-8npv4   1/1     Running   0          10m   10.244.1.3   kind-worker2   <none>           <none>
hello-world-deployment-5dc7657797-dmbvj   1/1     Running   0          19m   10.244.2.2   kind-worker    <none>           <none>
hello-world-deployment-5dc7657797-lb6gs   1/1     Running   0          10m   10.244.2.4   kind-worker    <none>           <none>
```

## Service

We got a deployment running and containers are running. But how do we access them? We need a `Service`!
What does a service do for you? It gets you an (internal) IP address that you can use to access your application. It also does load balancing for you! So if you have multiple pods, it will load balance between them (like those 3 we just made).
It also gets you an internal DNS entry `<name>.<namespace>.svc.cluster.local` that you can use to access your application from other pods (think databases). If you are working in the same namespace calling the service name as DNS name is enough!

There are 3 types of services:

- **ClusterIP**: This is the default type. It gives you an internal IP address that you can use to access your application from within the cluster.
- **NodePort**: It gives a random port that is accessible on the external IP of the node, it exposes it to the outside world. (it also creates a ClusterIP)
- **LoadBalancer**: It will create a load balancer in your cloud provider that you are using so you get an external IP address. (it also creates a ClusterIP)

```yaml
---
apiVersion: v1
kind: Service
metadata:
  name: hello-world-service
  namespace: default
spec:
  type: ClusterIP
  selector:
    app: hello-world
  ports:
    - protocol: TCP
      port: 80
      targetPort: http
```

Let's save this to a file called `service.yaml` and apply it!

```bash
kubectl apply -f service.yaml
```

```bash
$ kubectl get service
NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
hello-world-service   ClusterIP   10.96.82.17   <none>        80/TCP    3s
kubernetes            ClusterIP   10.96.0.1     <none>        443/TCP   3h50m
```

We notice we got the internal IP `10.96.82.17` assigned. But where does it point to? Let's check the endpoints!

```bash
$ kubectl get endpoints
NAME                  ENDPOINTS                                   AGE
hello-world-service   10.244.0.5:80,10.244.0.6:80,10.244.0.7:80   82s
kubernetes            172.20.0.2:6443                             3h51m
```

Just like Deployment created ReplicaSets, Services create Endpoints. Endpoints are just a list of IP addresses and ports that the service points to. In this case, it points to the 3 pods that we have running. If we scale up the deployment, the endpoints will be updated automatically.

Let's try to access it! For now it is only accessible from within the cluster. We can do this by using `kubectl port-forward` to forward a local port to the service.

```bash
kubectl port-forward service/hello-world-service 8080:80 --address='0.0.0.0'
```

This will forward port 8080 on your local machine to port 80 on the service. However it is not actually loadbalancing as this is a **debug** feature.

Now you can use curl, links  and browse to http://127.0.0.1:8080 or use your Windows browser and browse to the IP of your Linux host.

Do this a few times you will notice you get an answer from a different pod out of our 3 each time.

## Ingress

An Ingress is an important part of the average Kubernetes setup. It will be loadbalancing HTTP(S) for you. It also does virtualhost-based routing! By default Kubernetes supports path and host-based routing (port-based is called a NodePort Service).

The Ingress is often also responsible for terminating TLS connections for HTTPS and will be keeping certificates for you. This usually happens here as the overlay network is often encrypted by default.

![ingress](./ingress.png)

_Eyskens, M. (2018, April 18). Building a Kubernetes Ingress controller Â· https://eyskens.me/building-a-kubernetes-ingress-controller/_

While being important it does not ship by default in Kubernetes. You need to install an Ingress Controller. There are a few options:

- [NGINX Ingress Controller by Kubernetes](https://kubernetes.github.io/ingress-nginx/)
- [NGINX Ingress Controller by NGINX inc (an F5 company)](https://www.nginx.com/products/nginx/kubernetes-ingress-controller/)
- [Traefik](https://doc.traefik.io/traefik/providers/kubernetes-ingress/)
- [HAProxy](https://haproxy-ingress.github.io/)
- [Contour](https://projectcontour.io/)
- [Skipper by Zalando](https://opensource.zalando.com/skipper/kubernetes/ingress-controller/)

In this tutorial, we will be using the NGINX Ingress Controller [ingress-nginx](https://kubernetes.github.io/ingress-nginx/) by Kubernetes as it is supported by the Kubernetes Community.

The ingress controller is not installed by default in kind and most of the other Kubernetes flavors. To install in `kind`, we refer you to [the official installation instructions](https://kind.sigs.k8s.io/docs/user/ingress#option-2-extraportmapping). We recommend using *Option 2: extraPortMapping*.

You can create an ingress resource like all other resources using a YAML file.

```yaml
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: hello-world-ingress
  namespace: default
spec:
  rules:
    - host: hello-world.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: hello-world-service
                port:
                  name: http
```

:::tip
Not a fan of `/etc/hosts`, [messwithdns.net](https://messwithdns.net/) is a great tool to quickly get a DNS entry on the interwebs.
:::

Let's save this to a file called `ingress.yaml` and apply it!

```bash
kubectl apply -f ingress.yaml
```

Let's quickly cheat with DNS:

```bash
echo "127.0.0.1 hello-world.local" | sudo tee -a /etc/hosts
curl http://hello-world.local
```

You will now see the same hello-world page as before! But this time it is linked to a domain name, while still being loadbalanced as before!

:::tip
In production you probably want a proper HTTPS certificate. [cert-manager](https://cert-manager.io/docs/tutorials/acme/nginx-ingress/) is your friend to request one from Let's Encrypt using a few lines of YAML. (yes the author of this chapter is biased but it really is the best)
:::

## Probes
As we have HEALTHCHECK in Docker to monitor the health of our containers, we have probes in Kubernetes, used to monitor the state of our pods more closely.
There are 3 kinds of probes, startup probes, liveness probes and readiness probes. Each has it's own behavior and use case.

### Startup probes
A startup probe is used to check if a pod has started successfully. It's main use is to give containers that have a long initial startup time more time to start before Kubernetes designates it as failed. If the probe fails, Kubernetes will attempt the restart the pod.
A startup probe only checks a pod during the startup phase. Once the pod has successfully started, the startup probe does no more tests.

You use startup probes for any pod that takes a long time to initialize or is dependant on external resources, so Kubernetes doesn't consider it unhealthy prematurely.

### Liveness probes
Liveness probes periodically check whether an application is still running correctly. If the probe fails, Kubernetes will automatically attempt to restart the pod. The liveness probe will start testing once the startup probe succeeds.

This probe is used to help maintain availability by automatically recovering from failures inside pods.

### Readiness probes
Similar to liveness probes, readiness probes do a periodical check of a pod. But rather than checking if the pod is still running correctly, the readiness probe checks whether or not the pod is ready to accept traffic. When the readiness check fails, the pod will not be restarted. Rather, Kubernetes will try to route traffic to other pods until the pod is ready to accept traffic again.

This probe is mainly used for pods that need more time to initialize or are dependant on external resources.

## Probe tests
Besides the probes, there are 4 types of tests we can use to check our pods with.

### HTTP test
The HTTP test uses the `httpGet` command to execute a test. As the name implies, the probe sends an HTTP GET request to a specified path to determine the healthiness of the pod. If the pod returns an HTTP status code in the 200-399 range, the pod is considered healthy.
This test is very useful to check web applications and services.

### TCP test
The TCP test is executed with the `tcpSocket` command. This test tries to establish a connection with a specified port of the pod. If the connection succeeds, the test passes. Otherwise, like when no service is listening on that port, the test will fail.
This is a simpler test that only looks for a listening service on a port. The test does not guarantee that the application is working correctly.

### gRCP test
The gRCP test is done with the `grcp` command. This test is typically only used for microservices built with gRCP. Examples of these are the pods Kubernetes itself creates to run Kubernetes. It uses the gRCP protocol to check whether a service responds correctly to a health-check.

### Command Execution test
The final test executes custom commands directly in the pod. For this, it uses the `exec` command. If the command exits with a status code of 0, the probe is successful. With any other status code, the probe will indicate failure.
This is a very powerful tool to check whether an application is working successfully or not, but usually needs more knowledge about the application and pod itself to be used effectively.

## Example
Let's take our deployment from earlier and expand it with a startup probe, a liveness probe and a readiness probe.

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-world-deployment
  namespace: default
spec:
  selector:
    matchLabels:
      app: hello-world
  replicas: 1
  template:
    metadata:
      labels:
        app: hello-world
    spec: # this is our pod spec!
      containers:
        - name: nginx
          image: nginxdemos/hello
          ports:
            - containerPort: 80
              name: http # from now on we can use the name http to refer to this port
          startupProbe: # checks if the server is started correctly
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 2
            periodSeconds: 3
            failureThreshold: 5
          livenessProbe: # checks if the server still works every 5 seconds
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
          readinessProbe: # checks if the server is ready to accept traffic
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 2
```

## Other interesting resources

The above four are great to get started but there are many more to look into for building actually useful applications!
The Kubernetes documentation is a great place to start:

- [ConfigMap](https://kubernetes.io/docs/concepts/configuration/configmap/) - for mounting configuration files into containers
- [Secret](https://kubernetes.io/docs/concepts/configuration/secret/) - for mounting secrets into containers
- [CronJob](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/) - for running scheduled jobs
- [DaemonSet](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/) - for running a pod on every node
- [PresistentVolumeClaim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) - for requesting persistent storage to be added into containers
