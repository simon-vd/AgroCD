---
sidebarDepth: 1
---

# üî• NodeJS Tutorial

## Hello Node

Let's build our first "Hello Node" Node.js application. Of course, we'll be containerizing it as well.

Create a new folder called `hello-node` and create a file called `app.js` in it. Add the following code to the file:

```javascript
const http = require('http');
const hostname = '0.0.0.0';
const port = 3000;
const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello Node');
});
server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});
```

Next, we'll need a `package.json` file. This file contains information about the application and its dependencies. Create a new file called `package.json` and add the following code to it:

```json
{
  "name": "hello-node",
  "version": "1.0.0",
  "description": "Hello Node Test Application",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "author": "Your Name"
}
```

This file contains the following information:

| Property | Description |
| --- | --- |
| name | The name of the application. |
| version | The version of the application. |
| description | A description of the application. |
| main | The entry point of the application. The first file that will be executed. |
| scripts | A list of scripts that can be executed. |
| author | The author of the application. |


Now, let's have a look at the `node` image on Docker Hub: [https://hub.docker.com/_/node](https://hub.docker.com/_/node). The documentation on how to use the image can be found [here](https://github.com/nodejs/docker-node/blob/main/README.md#how-to-use-this-image).

:::danger EXERCISE 1
Use Docker Compose to run your application. Use the `node:20.9-alpine` image.
The expected result:
![](2023-10-30-14-55-19.png =50%x)

If you come across some `ENOTSUP` errors, it is because you are working with a volume pointing to a Vagrant synced folder in which node is not allowed to create symbolic links. In that case, it is better to use a `Dockerfile` and build the image first using the instructions in the documentation.
:::

### Adding Express

Now that we have a basic Node.js application, but working with the `http` module and handling API requests that way is a bit cumbersome. So, let's add the Express.js web framework to it. Create a new directory called `hello-node-express` and copy the `app.js`, `package.json` and `docker-compose.yaml` files from the `hello-node` directory to it.

Let's first add the Express.js dependency to our `package.json` file. We first create a `dependencies` object and add the `express` dependency to it. The `dependencies` object contains every library that our application depends on. These dependencies will be installed when `npm install` is executed.

```json
{
  "name": "hello-node",
  "version": "1.0.0",
  "description": "Hello Node Test Application",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "author": "Your Name",
  "dependencies": {
    "express": "^4.19.2"
  }
}
```

Next, we'll need to rewrite our `app.js` file to use Express.js. We'll also add a new route to our application. Add/modify the following code to the `app.js` file:

```javascript
const express = require('express');
const hostname = '0.0.0.0';
const port = 3000;

const app = express();

//Add a new API route
app.get('/hello', (req, res) => {
    res.json({
        message: 'Hello Node',
        date: new Date()
    });
});

//Print container id
app.get('/id', (req, res) => {
    res.json({
        container_id: process.env.HOSTNAME
    });
});

//Start the server
app.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}`);
});
```

Notice that we have now defined 2 API endpoints: `/hello` and `/id`. The `/hello` endpoint will return a JSON object with a message and the current date.
The `/id` endpoint will return the container ID. The container ID is retrieved from the `HOSTNAME` environment variable within the container.

At this point, it would be better to include the application and all dependencies inside the image. This will make it easier to move the image around and deploy it to, let's say, a Kubernetes cluster üòâ.

So let's add a `Dockerfile` that integrates the application and all dependencies into the image. 

:::danger EXERCISE 2
Create a `Dockerfile` that:

- uses the `node:lts-alpine` image, providing a lightweight image with the latest LTS (Long Term Support) version of Node.js.
- sets the working directory to `/home/node/app`
- copies the application code and `package.json` to `/home/node/app` in the image
- installs the dependencies defined in `package.json` using `npm install` during the build process.
- exposes the correct port
- runs `npm start` when the container is started

Build the image and run it. Use `docker run` or `docker compose` to run the container.
The API endpoints should be exposed and accessible:

![result api hello node](2024-07-30-10-53-42.png =50%x)
![result api container id](2024-07-30-10-54-17.png =50%x)
:::

### Back to the front(end)

We created the E and the N of the MEAN stack. Now let's focus on the A. We'll create a basic Angular frontend that will consume the API we created in the previous exercises.

#### Creating the Angular project

First we have to create a new Angular project in as subdirectory of the `hello-node-express` directory. We could install the Angular CLI on our machine, but we'll use the `node:lts-alpine` image to create the project. This way we don't have to install the Angular CLI, keep it up to date, or worry about different versions.

```bash
docker run -it --rm -v ${PWD}:/app -w /app node:lts-alpine npx @angular/cli new angular-frontend --standalone=false
```

This will create a new Angular boilerplate project in the `angular-frontend` directory. We use the `--standalone=false` flag to state that we don't want to create an app with standalone components.

Now we create a `hello` component that will include the code to consume the API. We'll use the Angular CLI to create the component:

```bash
cd angular-frontend
docker run -it --rm -v ${PWD}:/app -w /app node:lts-alpine npx ng generate component hello
``` 
This should have created the following directory structure in the `angular-frontend/src` directory:

```bash
$ tree angular-frontend/src
angular-frontend/src
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.component.css
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.component.html
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.component.spec.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.component.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.module.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app-routing.module.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ hello
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ hello.component.css
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ hello.component.html
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ hello.component.spec.ts
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ hello.component.ts
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ main.ts
‚îî‚îÄ‚îÄ styles.css
```

Replace the `hello.component.ts` file with the following code:

```typescript
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-hello',
  templateUrl: './hello.component.html',
  styleUrls: ['./hello.component.css']
})
export class HelloComponent implements OnInit {
  message: string = '';
  date: string = '';

  constructor(private http: HttpClient) { }

  ngOnInit(): void {
    this.http.get<{ message: string, date: string }>('http://192.168.56.5:3000/hello')
      .subscribe(data => {
        this.message = data.message;
        this.date = data.date;
      });
  }
}
```

Notice the part where we use the `HttpClient` to make a GET request to the `/hello` endpoint of our API. We subscribe to the observable and set the `message` and `date` properties of the component with the data we receive from the API.

Next, replace the `hello.component.html` file with the following code:

```html
<div>
    <h1>{{ message }}</h1>
    <p>{{ date }}</p>
</div>
```

This code will display the message and date we receive from the API.

Now we have to add the `HttpClientModule` to the `AppModule` so we can use the `HttpClient` in our components. We also add the `RouterModule` to the `AppModule` so we can use the Angular Router. Replace the `app.module.ts` file with the following code:

```typescript 
import { BrowserModule, bootstrapApplication } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { provideHttpClient } from '@angular/common/http';

import { AppComponent } from './app.component';
import { HelloComponent } from './hello/hello.component';
import { RouterModule } from '@angular/router';


@NgModule({
  declarations: [
    AppComponent,
    HelloComponent
  ],
  imports: [
    BrowserModule,
    RouterModule
  ],
  providers: [provideHttpClient()],
  bootstrap: [AppComponent]
})
export class AppModule { }
```
Now, we need to include the hello component in the `app.component.html` file. Edit the file, find the following lines, comment them out, and replace them with the code below:

```html
<!-- <h1>Hello, {{ title }}</h1>
<p>Congratulations! Your app is running. üéâ</p> -->
<div>
  <h1>Welcome to my Messages App! üíå</h1>
  <app-hello></app-hello>
</div>
```
The `<app-hello>` tag points to the location where Angular will render our `hello` component in the html file, effectively printing the message and date we receive from the API.

#### Building and serving the Angular application

Now that we have our application code in place, we need to build the Angular application and serve it using a web server. We'll use the `nginx:alpine` image for this. This image is a lightweight image that contains the Nginx web server.

Create this `Dockerfile` in the `angular-frontend` directory:

```Dockerfile
# Dockerfile for Angular frontend
# First "build" stage uses the node:lts-alpine image as a base image. Copies the Angular application files and install npm dependencies.
# This container is used solely for building the Angular application, after which the built files are copied to the nginx:alpine image and the build container is discarded.
FROM node:lts-alpine AS build

WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install
COPY . .
RUN npm run build --prod

# Second "deployment" stage uses the nginx:alpine image as a base image. Copies the Angular application files to the nginx html directory and runs the nginx server serving the Angular application.
FROM nginx:alpine
COPY --from=build /app/dist/angular-frontend/browser /usr/share/nginx/html

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

Here we are using feature of the `Dockerfile` we haven't used before: multi-stage builds. This feature allows us to use multiple `FROM` statements in a single `Dockerfile`. Each `FROM` statement starts a new build stage, and the final image is built from the last build stage. 

This allows us to first build the Angular application using the tools in the node container first. This will convert our complex and verbose TypeScript code into static HTML, CSS, and JavaScript files. We don't want to use the build-in development server of Angular to serve this application however, it is not suitable for production.

Instead, we will copy the files from the build stage to the Nginx container. The Nginx container will serve the static files and run the Angular application.

Notice the `--from=build` flag in the `COPY` statement. This flag tells Docker to copy the files from the `build` stage to the `deployment` stage. 

:::danger EXERCISE 3
Include the Angular front-end in the `docker-compose.yaml` file. Build and run the stack.
:::

The result,  ta-da!! üéâ 

But...

![the result, Tada!](2024-07-30-18-37-56.png =50%x)

Why is the message not displayed? ü§î 

It's important to realize now that this front-end application is made up out of static files that are served to your browser by the Nginx server. The application (js) code is running in your browser, not on the server. If we want to troubleshoot this, we will have to look at the browser console. Press `F12` to open the developer tools and navigate to the console tab. You will see the following error:

```js
192.168.56.5/:1 Access to XMLHttpRequest at 'http://192.168.56.5:3000/hello' from origin 'http://192.168.56.5' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

This points to an important security feature that web browsers have implemented in recent years: the Same-Origin Policy. This policy prevents a web page from making requests to a different domain than the one that served the page. This prevents malicious websites from making requests to other websites on your behalf, which can result in CSRF (Cross-Site Request Forgery) attacks.

![Same origin policy](2024-07-30-18-48-01.png =50%x)

In our case, the Angular application is served from the web server running at `http://192.168.56.5` and it requests data from the API running at `http://192.168.56.5:3000`. Different ports are considered different origins by the browser, so the request is blocked. What are also considered different origins are different protocols (http vs https), different domains (google.com vs facebook.com) or different IP addresses.

If we want to allow the Angular application to make requests to the API, we have to configure the API to allow requests from the Angular application. This can be done by setting the `Access-Control-Allow-Origin` header in the response of the API. This header tells the browser that the API allows requests from the Angular application. The mechanism to set this header is called CORS (Cross-Origin Resource Sharing). More information about CORS can be found [here](https://medium.com/@tbgarza2/basics-of-same-origin-policy-and-cors-1e77882a43b).

#### Adding CORS to the API

We can add CORS support to the Express.js API (`app.js`) by using the `cors` middleware. 

```js
//import cors module
const cors = require('cors');

//set allowed origins for CORS
var corsOptions = {
    origin: 'http://192.168.56.5',
}

//Enable CORS
app.use(cors(corsOptions));
```
We also have to add the `cors` dependency to the `package.json` file:

```json
{
  "name": "hello-node",
  "version": "1.0.0",
  "description": "Hello Node Test Application",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "author": "Your Name",
  "dependencies": {
    "express": "^4.19.2",
    "cors": "^2.8.5"
  }
}
```

With this code, the API will allow requests from `http://192.168.56.5` only! Other applications served from different origins will not be able to make requests to the API. That's the power of CORS! üõ°Ô∏è

:::danger EXERCISE 4
Rebuild and run the stack.

![End result](2024-07-30-19-01-03.png =50%x)

Congrats, you built a EAN stack! üéâ
We will talk about MongoDB in the next chapter.
:::



### Push to Docker Hub

In order to deploy our application to a Kubernetes cluster, we'll need to push the images to a registry. We'll use Docker Hub for this. If you don't have a Docker Hub account yet, create one [here](https://hub.docker.com/signup).

First, login to Docker Hub using the `docker login` command:

```bash
$ docker login
```

Now, we first have to retag the image to match the Docker Hub repository name. The format of the repository name is `<username>/<repository-name>`. So, if your username is `john` and the repository name is `hello-node-express`, the repository name will be `john/hello-node`. Retag the image using the following command:

```bash
$ docker tag <image-id> <username>/<repository-name>:<tag>
```
You should see a new tag for the same image (notice that they have the same image ID):

```bash
$ docker images
REPOSITORY                                     TAG          IMAGE ID       CREATED        SIZE
bramverbruggen/hello-node-express-node            latest       45a0e58a14da   17 hours ago   140MB
hello-node-express-node                        latest       45a0e58a14da   17 hours ago   140MB
```
Now we can push the image to Docker Hub using the `docker push` command:

```bash
$ docker push <username>/<repository-name>:<tag>
```

You will now find the pushed image in your Docker Hub repository:

![Docker Hub Repo](2024-07-31-12-01-35.png =50%x)

:::danger EXERCISE 5
Push the Angular front-end image to Docker Hub, as well.
:::

### Deploy to Kubernetes

Let's get this app shipped! You need a k8s cluster, for example using `kind`, for this exercise.

:::danger EXERCISE 6
Write and apply a k8s manifest for the EAN stack. Use the images you pushed to Docker Hub in the previous exercise. The deployments should have 3 replicas. The application should be accessible on port 80. The manifest should contain:
- a deployment that creates the pods
- a service that exposes the pods and divides the traffic over the pods
- an ingress that exposes the service to the outside world and routes the traffic to the service. Use `messwithdns.net` or the hosts file to create a DNS entry for the ingress.


```bash
$ kubectl get pods                               main-!?
NAME                                               READY   STATUS    RESTARTS   AGE
hello-node-express-angular-front-85fdb866b-8n2fv   1/1     Running   0          3m59s
hello-node-express-angular-front-85fdb866b-v9mvg   1/1     Running   0          4m3s
hello-node-express-angular-front-85fdb866b-wd9h7   1/1     Running   0          4m6s
hello-node-express-api-6d47848ffb-26d5t            1/1     Running   0          9s
hello-node-express-api-6d47848ffb-6c8fq            1/1     Running   0          13s
hello-node-express-api-6d47848ffb-cpxjx            1/1     Running   0          6s
```

![result k8s hello node express](2024-07-31-12-42-57.png =50%x)
![result k8s hello node express](2024-07-31-12-43-20.png =50%x)
![result k8s hello node express](2024-07-31-12-44-14.png =50%x)


After one or two page refreshes, you should see the container ID change.
:::



